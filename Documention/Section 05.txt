5.42. Introduction 
-> sorting
-> filtering
-> searching
-> paging


Pagination:
-> performance
-> parameters passed by query string:
  /api/products?pageNumber=3&pageSize=10  
-> page size should be limited
-> we should always page results

Deferred Execution:
-> when we're building our query, we're not hitting our database, we deferring it until we got the query
-> each part of the query built up as an expression three, and then goes to the database

Steps:
-> query commands are stored in a variable
-> execution of that query will be deferred
-> IQueryable<T> creates an expression three
-> Execution:
    -> ToList(), ToArray(), ToDictionary()
    -> Count() or other singleton queries


5.43. Creating product spec parameters

-- Core -> Specifications -> ProductSpecParams.cs --
List<string> Brands
List<string> Types
string? Sort { get; set; }

-- Core -> Specifications -> ProductSpecification.cs --
public ProductSpecification(ProductSpecParams specParams) : base(x =>
    (specParams.Brands.Count == 0 || specParams.Brands.Contains(x.Brand)) &&
    (specParams.Types.Count == 0 || specParams.Types.Contains(x.Type)))

-- API -> Controllers -> ProductsController.cs --
GetProducts([FromQuery] ProductSpecParams specParams)


5.44. Adding Pagination part 1
-- Infrastructure -> Data -> ProductRepository.cs --

return await query.Skip(5).Take(5).ToListAsync();
-> we need to find a way to apply this to our Specification Pattern

-- Core -> Interfaces -> ISpecification.cs --
int Take { get; }
int Skip { get; }
bool IsPagingEnabled { get; }

-- Core -> Specifications -> BaseSpecification.cs --
public int Take { get; private set; }
public int Skip { get; private set; }
public bool IsPagingEnabled { get; private set; }
protected void ApplyPaging(int skip, int take) { ...}

-- Infrastructure -> Data -> BaseSpecification.cs --
if (spec.IsPagingEnabled)
    query = query.Skip(spec.Skip).Take(spec.Take);

if (spec.IsPagingEnabled)
    selectQuery = selectQuery?.Skip(spec.Skip).Take(spec.Take);