9.73. Introduction
-> Angular services
    -> make our http response 
    -> are singleton in our app         

-> Building the UI for the shop
    -> Angular Material
    -> Tailwind CSS

-> Pagination (from Angular Material)

-> Filtering, Sorting & Search

-> Input properties
    -> as we creates more components, we will break them in smaller pieces
    -> we will pass the properties from the parent component to the child component


9.74. Introduction to Angular services
-> to make a http request, we need to make a service 
-> Angular services are singletons
-> when we generate components in our app, and we move around from 
component to component, the data is created and destroyed when the leave those
component
-> the only way to persist is to use services 
-> all our services are in the "core" folder

-- open terminal --
cd skinet/client
ng g --help
ng g s core/services/shop --dry-run
ng g s core/services/shop --skip-tests

We gonna shift from app component to services:

-- shop.services.ts --
export class ShopService {
  baseUrl = "https://localhost:7096/api/"
  // inject HTTP Client
  private http = inject(HttpClient);

  getProducts() {
    return this.http.get<Pagination<Product>>(this.baseUrl + 'products')
  }
}

-- app.component.ts --
private shopService = inject(ShopService);
... 
this.shopService.getProducts().subscribe({...})


Dictionary:
-- shop.services.ts --
@Injectable         -> we can inject this service wherever we need it our Angular code
providedIn: 'root'  -> when the app is start running, is provided in the entire app


9.75. Designing the shop page
https://material.angular.io/components/card/overview

-- terminal --
cd skinet/client
ng g c features/shop --dry-run
ng g c features/shop --skip-tests

g -> generate
c -> component

-- app.component.ts --
import { Component } from '@angular/core';
import { HeaderComponent } from "./layout/header/header.component";
import { ShopComponent } from "./features/shop/shop.component";

@Component({
  selector: 'app-root',
  standalone: true,
  templateUrl: './app.component.html',
  styleUrl: './app.component.scss',
  imports: [HeaderComponent, ShopComponent],
})
export class AppComponent {
  title = 'Skinet';
}

-- shop.component.html --
<app-header></app-header>
<div class="container mt-6">
    <app-shop></app-shop>
</div>

-- shop.component.ts --
import { Component, inject, OnInit } from '@angular/core';
import { ShopService } from '../../core/services/shop.service';
import { Product } from '../../shared/models/products';
import { MatCard } from '@angular/material/card';

@Component({
  selector: 'app-shop',
  standalone: true,
  templateUrl: './shop.component.html',
  styleUrl: './shop.component.scss', 
  imports: [MatCard]
})
export class ShopComponent implements OnInit {
  private shopService = inject(ShopService);
  products: Product[] = [];

  ngOnInit(): void {
    this.shopService.getProducts().subscribe({
      next: response => this.products = response.data,
      error: error => console.log(error)
    })
  }
}

-- shop.component.html --
<div class="grid grid-cols-5 gap-4">
    @for (product of products; track product.id) {
    <mat-card appearance="raised">
        <img src="{{product.pictureUrl}}" alt="image of {{product.name}}">
    </mat-card>
    }
</div>


-- shop.service.ts  --
return this.http.get<Pagination<Product>>(this.baseUrl + 'products?pageSize=20');


9.76. Adding a product item component

cd skinet/client
ng g c features/shop/product-item --skip-tests 

-- product-item.component.ts --
import { Product } from '../../../shared/models/products';

imports: [MatCard]

export class ProductItemComponent {
  @Input() product?: Product;
}

Files that need to be changed:
-- product-item.component.ts
imports: [MatCard, MatCardContent, CurrencyPipe, MatCardActions, MatButton, MatIcon]

-- product-item.component.html
all the component

-- shop.component.html
(passing param to child component)
<app-product-item [product]="product"></app-product-item>


9.77. Getting the types and brands lists

-- shop.service.ts --
getBrands() 
getTypes()

-- shop.component.ts --
initializeShop()


9.78. Adding filtering functionality using Material Dialog I

https://next.material.angular.io/components/dialog/overview

ng g c features/shop/filter-dialog --skip-tests

-- app -> features -> shop -> filter-dialog.component.ts --
shopService = inject(ShopService);

-- app -> features -> shop -> filter-dialog.component.html --
-> create 2 divs(for Brands and Types) and a button(Apply Filters)


Dictionary:
<mat-divider>
https://material.angular.io/components/divider/overview

<mat-selection-list>, <mat-list-option> :
https://material.angular.io/components/list/overview#selection


9.79. Adding filtering functionality using Material Dialog II

-- shop.component.ts --
imports: [MatCard, ProductItemComponent, MatButton]

private dialogService = inject(MatDialog);

openFiltersDialog() {
  const dialogRef = this.dialogService.open(FilterDialogComponent, {
  });
}

-- shop.component.html --
<div class="flex flex-col gap-3">
  <div class="flex justify-end">
    <button mat-stroked-button (click)="openFiltersDialog()">
      <mat-icon>filter_list</mat-icon>
    </button>
  </div>
</div>

How can i get a icon in the button?
https://fonts.google.com/icons 
search for the icon: Filter List
in the right bar search for: "Inserting the icon"
https://fonts.google.com/icons?selected=Material+Symbols+Outlined:filter_list:FILL@0;wght@400;GRAD@0;opsz@24&icon.query=filter&icon.size=24&icon.color=%235f6368


Make the filter functional:

-- shop.component.ts --
  selectBrands: string[] = [];
  selectTypes: string[] = [];

  openFiltersDialog() {
    const dialogRef = this.dialogService.open(FilterDialogComponent, {
      width: '500px',
      data: {
        selectBrands: this.selectBrands,
        selectTypes: this.selectTypes
      }
    });

    dialogRef.afterClosed().subscribe({
      next: result => {
        if (result) {
          this.selectBrands = result.selectBrands;
          this.selectTypes = result.selectTypes;
          // apply filters
        }
      }
    });
  }

  We need to do something to access to the data:
  -- filter-dialog.component.ts --

  export class FilterDialogComponent {
  shopService = inject(ShopService);
  private dialogRef = inject(MatDialogRef<FilterDialogComponent>);
  data = inject(MAT_DIALOG_DATA);

  selectBrands: string[] = this.data.selectBrands;
  selectTypes: string[] = this.data.selectTypes;

  applyFilters() {
    this.dialogRef.close({
      selectBrands: this.selectBrands,
      selectTypes: this.selectTypes
    })
  }
}

9.80. Hooking up the filters to the service

Duo-way biding: FormsModule
-> get data from the template
-> modify the data in the template 

-- filter-dialog.component.html --
[] -> input values (modify the UI)
() -> output values (read from UI)

[(ngModel)]="selectBrands" [multiple]="true"
value="{{brand}}"
(click)="applyFilters()"

<mat-selection-list [(ngModel)]="selectBrands" [multiple]="true">
    @for (brand of shopService.brands; track $index) {
    <mat-list-option value="{{brand}}">{{brand}}</mat-list-option>
    }
</mat-selection-list>

<mat-selection-list [(ngModel)]="selectTypes" [multiple]="true">
    @for (type of shopService.types; track $index) {
    <mat-list-option value="{{type}}">{{type}}</mat-list-option>
    }
</mat-selection-list>

<button mat-flat-button (click)="applyFilters()">Apply Filters</button>


-- app -> core-> services -> shop.service.ts --
-> rewrite the getProducts()

 getProducts(brands?: string[], types?: string[]) {
  let params = new HttpParams();

  if (brands && brands.length > 0) {
    params = params.append('brands', brands.join(','));
  }

  if (types && types.length > 0) {
    params = params.append('types', types.join(','));
  }

  params = params.append('pageSize', 20);

  return this.http.get<Pagination<Product>>(this.baseUrl + 'products', { params });
}

-- shop.component.ts --
// apply filters
this.shopService.getProducts(this.selectBrands, this.selectTypes).subscribe({
  next: response => this.products = response.data,
  error: error => console.log(error)
})


81. Adding the sorting functionality

-- shop.component.ts --
import { MatMenu, MatMenuTrigger } from '@angular/material/menu';
import { MatListOption, MatSelectionList } from '@angular/material/list';

@Component{
  ...
  [imports] : [..., MatMenu, MatMenuTrigger, MatListOption, MatSelectionList]
}

class ShopComponent{
...
selectedSort: string = 'name';
sortOptions = [
  { name: 'Alphabetical', value: 'name' },
  { name: 'Price: Low-High', value: 'priceAsc' },
  { name: 'Price: High-Low', value: 'priceDesc' }
]

 getProducts() {
    this.shopService.getProducts(this.selectBrands, this.selectTypes, this.selectedSort).subscribe({
      next: response => this.products = response.data,
      error: error => console.log(error)
    })
  }

  onSortChange(event: MatSelectionListChange) {
    // we select the first option on the list by default
    const selectedOption = event.options[0];
    if (selectedOption) {
      this.selectedSort = selectedOption.value;
      this.getProducts();
    }
  }
}


-- shop.component.html --
<button mat-stroked-button [matMenuTriggerFor]="sortMenu">
    <mat-icon>swap-vert</mat-icon>
    Sort
</button>

swap-vert:
https://fonts.google.com/icons?selected=Material+Symbols+Outlined:swap_vert:FILL@0;wght@400;GRAD@0;opsz@24&icon.query=swap&icon.size=24&icon.color=%235f6368


<mat-menu #sortMenu="matMenu">
    <!-- [multiple]: select multiple options when filtering -->
    <mat-selection-list [multiple]="false" (selectionChange)="onSortChange($event)">
        @for (sort of sortOptions; track $index) {
        <mat-list-option [value]="sort.value" [selected]="selectedSort === sort.value">
            {{sort.name}}
        </mat-list-option>
        }
    </mat-selection-list>
</mat-menu>


-- shop.service.ts --
-> add the sort logic/param
getProducts(brands?: string[], types?: string[], sort?: string){
...
  if (sort) {
    params = params.append('sort', sort);
  }
}


Dictionary:



82. Using a class for supply the params for the API request 

83. Adding pagination to the client using Material

84. Adding the search functionality to the client

85. Summary