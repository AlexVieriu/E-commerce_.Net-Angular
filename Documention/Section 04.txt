28. Introduction

-> creating a generic repository
-> specification pattern
-> using of specification pattern
-> using the Debugger
-> shaping data

About generics:
-> since 2002
-> help avoid code duplication
-> type safety(code replaced at compile time, not runtime)


29. Creating a generic repository

-- Core -> Interfaces -> IGenericRepository.cs --
-- Infrastructure -> Data -> GenericRepository.cs --


30. Implementing the generic repository

ChatGPT:
I have a C# course , that is using 
"context.Set<T>().Attach(entity);
context.Entry(entity).State = EntityState.Modified;" 
instead of simple version :" context.Update(entity);" and i wanna know why?


31. Generic Repository in the Controller

-- API -> Controllers -> ProductsController.cs --


32. Specification pattern
-> describes a query in an object
-> returns a IQueryable<T>
-> generic List method takes specification as parameter


33. Setting up the specification classes

-- Core -> Interfaces -> ISpecification.cs --       
Expression<Func<T, bool>> Criteria { get; }

-- Specifications ->  BaseSpecification.cs --  
public Expression<Func<T, bool>> Criteria => criteria;

-- Infrastructure -> Data -> SpecificationEvaluator.cs --
public static IQueryable<T> GetQuery(IQueryable<T> query, ISpecification<T> spec)
{...}


34. Using the specification pattern

-- Core -> Specifications -> ProductFilterSpecification.cs --

public ProductSpecification(string? brand, string? type) : base(x =>
(string.IsNullOrWhiteSpace(brand) || x.Brand == brand) &&
(string.IsNullOrWhiteSpace(type) || x.Type == type))
{

}

-> the good part of this approach is that we don't need to write validation
methods for every single endpoint when we use the ProductSpecification.cs

-- Infrastructure -> Data -> GenericRepository.cs --

public async Task<T?> GetEntityWithSpec(ISpecification<T> spec)
{
    return await ApplySpecification(spec).FirstOrDefaultAsync();
}


4.36. Adding sorting to the specification

-- Core -> Specifications --

-> ProductSpecification.cs
Expression<Func<T, object>>? OrderBy { get; }
Expression<Func<T, object>>? OrderByDescending { get; }

-> BaseSpecification.cs
OrderBy { get; private set; }
OrderByDescending { get; private set; }
void AddOrderBy(Expression<Func<T, object>> orderByExpression) {}
void AddOrderByDescending(Expression<Func<T, object>> orderByDescendingExpression) {}

-- Infrastructure -> Data -> SpecificationEvaluator.cs --
if (spec.OrderBy != null)
    ...
if (spec.OrderByDescending != null)
    ...

-- Core -> Specifications -> ProductSpecification.cs --
-> creating switch cases for "priceAsc" and "priceDesc", with default "priceAsc"


4.37. Using the Debugger

Why we build the app this way?
-> image you have 100 entities, 100 repositories, 100 specification files
