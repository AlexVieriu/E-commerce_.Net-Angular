28. Introduction

-> creating a generic repository
-> specification pattern
-> using of specification pattern
-> using the Debugger
-> shaping data

About generics:
-> since 2002
-> help avoid code duplication
-> type safety(code replaced at compile time, not runtime)


29. Creating a generic repository

-- Core -> Interfaces -> IGenericRepository.cs --
-- Infrastructure -> Data -> GenericRepository.cs --


30. Implementing the generic repository

ChatGPT:
I have a C# course , that is using 
"context.Set<T>().Attach(entity);
context.Entry(entity).State = EntityState.Modified;" 
instead of simple version :" context.Update(entity);" and i wanna know why?


31. Generic Repository in the Controller

-- API -> Controllers -> ProductsController.cs --


32. Specification pattern
-> describes a query in an object
-> returns a IQueryable<T>
-> generic List method takes specification as parameter


33. Setting up the specification classes

-- Core -> Interfaces -> ISpecification.cs --       
Expression<Func<T, bool>> Criteria { get; }

-- Specifications ->  BaseSpecification.cs --  
public Expression<Func<T, bool>> Criteria => criteria;

-- Infrastructure -> Data -> SpecificationEvaluator.cs --
public static IQueryable<T> GetQuery(IQueryable<T> query, ISpecification<T> spec)
{...}


34. Using the specification pattern

-- Core -> Specifications -> ProductFilterSpecification.cs --

public ProductSpecification(string? brand, string? type) : base(x =>
(string.IsNullOrWhiteSpace(brand) || x.Brand == brand) &&
(string.IsNullOrWhiteSpace(type) || x.Type == type))
{

}

-> the good part of this approach is that we don't need to write validation
methods for every single endpoint when we use the ProductSpecification.cs

-- Infrastructure -> Data -> GenericRepository.cs --

public async Task<T?> GetEntityWithSpec(ISpecification<T> spec)
{
    return await ApplySpecification(spec).FirstOrDefaultAsync();
}
