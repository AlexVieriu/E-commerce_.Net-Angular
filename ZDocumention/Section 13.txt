13.112. Introduction

-> adding the cart feature
-> angular signals
-> environment variables

Goal:
-> add cart features to angular app
-> understand the usage of signals in Angular


13.113. Creating the cart components

ng g s core/services/cart --skip-tests
ng g c features/cart --skip-tests

-- app.routes.ts --
{ path: 'cart', component: CartComponent }

-- header.component.html --
-> add the link to shopping cart
<a routerLink="/cart" routerLinkActive="active"...

echo "" > src/app/shared/models/cartItem.ts
--cartItem.ts--


echo "" > src/app/shared/models/cartType.ts
-- cartType.ts --


echo "" > src/app/shared/models/cart.ts
-- cart.ts --

-> a tiny, secure, URL-friendly, unique string ID generator for JavaScript
-> https://github.com/ai/nanoid
npm install nanoid


Dictionary:
-- Nanoid vs GUID --

Use nanoid when:
-> You need shorter, readable, and customizable IDs
-> You want a lightweight solution without adhering to UUID specifications
-> Performance and efficiency are important (e.g., generating many IDs quickly)
-> The IDs will not need to conform to standardized UUID formats 
(e.g., for APIs expecting GUIDs)

Use GUID when:
-> You require strict adherence to UUID standards (e.g., 
for database keys or APIs that expect GUIDs)
-> Interoperability with other systems or languages that expect UUIDs is necessary
-> The larger size and format aren't a concern


13.114. Angular signals
-> state that can be observed and reacted to
-> clean API for state management
-> avoid the complexity of observables
https://next.angular.dev/essentials/signals

# We will use 3 main Types:
-> signal 
    -> get, set, update a value(int, object, etc.)
-> computed
-> effect

-- Signal --
const count = signal(0);

// Signals are getting functions - calling them reads their value
console.log("The count is: " + count());

// Set a new value
count.set(1);

// Update a value
count.update(value => value + 1);

Pros:
-> Simplicity
    -> gives as a API for managing the state of the app, 
    without the complexity of observables
    -> small footprint
-> Performance    
-> Readability

Cons:
-> Limited flexibility
    -> less mature (Angular 16) 
    -> observables: more mature (Angular 2)
-> Scalability


13.115. Adding the Cart service methods

ng g --help
ng g environments

-- environment.development.ts --
export const environment = {
    production: false,
    apiUrl: 'https://localhost:7096/api/'
};

-- environment.ts --
export const environment = {
    production: true,
    apiUrl: 'api/'
};

-- cart.service.ts --
baseUrl = environment.apiUrl;
private http = inject(HttpClient);
cart = signal<Cart | null>(null);

 getCartAsync(){...}
 setCartAsync(cart: Cart){...}


13.116. Adding item to cart

-- cart.service.ts --

addItemToCart(item: CartItem | Product, quantity = 1){...}
private createCart(): Cart{...} 
private mapProductToCartItem(product: Product): CartItem {...}

// type guard
private isProduct(item: CartItem | Product): item is Product {
    return (item as Product).id !== undefined;
}

-> the function returns "item is Product"


Dictionary:
"undefined"
-> a variable has been declared but was never assigned a value
-> if a function doesn't return a value, it returns "undefined"

Ex 1:
let x;
console.log(x); // Output: undefined

Ex 2:
const person = { name: "Alice" };
console.log(person.age); // Output: undefined

-- "!= vs !==" --

0 !== false         -> true 
null !== undefined  -> true 

0 != false          -> false 
null != undefined   -> false 

0 == false          -> true
0 === false         -> false

null == undefined   -> true
null === undefined  -> false

ChatGPT:
"Why not check the object type directly in the body?"

private isProduct(item: object): void {
  if (item instanceof Product) {
    // do something for Product
  } else if (item instanceof CartItem) {
    // do something else for CartItem
  }
}

"instanceof"
-> used to check whether an object is an instance of a class
-> check if item is instance of Product or CartItem

Compile-Time: TypeScript types, interfaces, generics
Runtime     : JavaScript objects, classes, functions, variables.

-> if Product and CartItem are types/interfaces, you will get 
compile-time errors with "instanceof"
-> you need to rely on property checks or type guards

private isProduct(item: object): void {
  if ((item as Product).id !== undefined) {
    // do something for Product
  } else if ((item as CartItem).id !== undefined) {
    // do something else for CartItem
  }
}


13.117. Using the add item functionality in the product item

-- product-item.component.ts --
  cartService = inject(CartService);

-- product-item.component.html --
<mat-card-actions (click)="$event.stopPropagation()">
(click)="cartService.addItemToCart(product)"

Testing:
-> chrome -> network
    -> check headers (we see a POST)
    -> check payload (we see the items[])
-> check redis

Dictionary:
"$event.stopPropagation()":
-> prevent routerLink="/shop/{{product.id}}" to be access
when we use the click event

