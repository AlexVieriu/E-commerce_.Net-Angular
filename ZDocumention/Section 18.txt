197. Introduction 
-> client side orders 
    -> then they create a payment, the order will be created    

-> webhooks
    -> allow Stripe to communicate directly with the API, and notify the API
    that the payment was successful
    -> stripe and backend API will share a secret

-> signalR
    -> we need to notify the client that the payment was successful
    without the client giving us a request      


SignalR
-> provides  real-time functionality
-> automated connection management

Supports:
-> websockets
-> server-sent events
-> long-polling

Good for:
-> dashboards
-> monitoring apps 
-> apps that require notifications
-> chat apps


198. Creating the order components

ng g s core/services/order --skip-tests
ng g c features/orders/order --skip-tests --flat
ng g c features/orders/order-detailed --skip-tests

https://transform.tools/json-to-typescript

-> make a call to {{localhost}}/api/order/1   
-> copy from Postman into the JsonToTs link 
-> make interfaces for each class

Why interfaces and not types or classes:
-> it's best practice to use interfaces when working with APIs

-- order.service.ts --
createOrder(orderToCreate: OrderToCreate){. . .}
getOrdersForUser(){. . .}
getOrderDetailed(id: number){. . .}

-- app.routes.ts --
{ path: 'orders', component: OrderComponent, canActivate: [authGuard] },
{ path: 'order/:id', component: OrderDetailedComponent, canActivate: [authGuard] },


Dictionary:

--flat 
-> create the 3 files without making a folder
-> when we create a component, Angular creates a folder and puts the 3 files(.ts, .html, .css) in it

Interfaces, Types, Classes in TypeScript:

1. Interfaces
-> only exists at compile-time (no JavaScript output)
-> can be extended with extends
-> can be merged with other interface declarations (declaration merging)
-> primarily focused on object 

When to use:
-> when defining object shapes, especially for public APIs
-> when you want to benefit from declaration merging
-> when creating object types that might be extended later

2. Types
-> only exists at compile-time (no JavaScript output)
-> can represent any type (unions, intersections, primitives, etc.)
-> cannot be extended directly (but can use intersection types)
-> cannot be merged with other declarations

When to use:
-> when you need union types (type Status = 'pending' | 'shipped')
-> when you need complex types like mapped types, conditional types
-> when you don't need declaration merging
-> when you want to create type aliases for functions, tuples, etc.

3. Classes
-> exists at runtime (produces JavaScript code)
-> can have constructors, methods, and property implementations
-> can be instantiated with new
-> supports inheritance with extends
-> can implement interfaces

When to use:
-> when you need to create instances with new
-> when you need methods and behavior along with data
-> when you need inheritance hierarchies
-> when you need to implement interfaces
-> when working with object-oriented patterns


199. Submitting the order

-- checkout.component.ts --
-> inject the OrderService

confirmPayment(stepper: MatStepper){
    -> check if confirmationToken exists
    -> get the payment confirmPayment form Stripes with confirmToken
    -> if succeeded
        -> createOrderModel() : return a Promise of OrderToCreate
            -> get the cart from the cartService
            -> get shipping address from stripe
            -> get the card from stripe
            -> return OrderToCreate mapped from striped 
        -> create order by passing the OrderToCreate obj to the API
        -> if Order was created
            -> delete Cart
            -> set delivery to null
            -> go to /checkout/success
        -> else throw Order creation failed from API
        -> else throw stripe error
        -> else throw string Error :" Something went wrong with the payment confirmation"
}

-> test it
-> we need to see in the DB, a new Order

Refactoring:

-- appsettings.json --
{
    "Logging": {
        "LogLevel": {
            "Default": "Information",
            "Microsoft.AspNetCore": "Information"
        }
    },
    "ConnectionStrings": {
        "DefaultConnection": "Data Source=../data/store.db",
        "Redis": "localhost"
    },
    "StripeSettings": {
        "SecretKey": "sk_test_51R3BtWGMOucV11LeOaDO00p6Ffd5e02R1j5xYUhcNejDA2TJOskB7saG2S2AtI5CaOq1mC1dpSNMkTJMntEP3qVe0053pPawgf"
    }
}

-- OrderController.cs --
return Create() -> return Created(uri: $"/api/order/{order.Id}", value: order);


200. Designing the order component to display orders

-> get the Orders in the API and display them in the interface

-- order.component.ts --
imports: [RouterLink, DatePipe, CurrencyPipe]

-> inject the OrderService
-> implement OnInit
    -> return the orders from the API


201. Creating the order detailed page

-- order-detailed.component.ts --
-> get the order from the API

imports: [MatCardModule, DatePipe, CurrencyPipe]

-> inject OrderService and ActivatedRoute
-> implement OnInit
    -> get the id: this.activatedRoute.snapshot.paramMap.get('id');
    -> get the order from the API with id


-- order-detailed.component.html --


202. Updating the address pipe with type guards

-- order-detailed.component.html --
-> add a button to go back to /orders
<dt class="mt-1 font-high">{{order.shippingAddress | address }}</dt>
<dt class="mt-1 font-high">{{order.paymentSummary | paymentCard }}</dt>

-- address.pipe.ts --
transform(value?: ConfirmationToken['shipping'] | ShippingAddress, ...args: unknown[]): unknown {
    if (value && 'address' in value && value.name) {
        const { line1, line2, city, state, postal_code, country } =
        (value as ConfirmationToken['shipping'])?.address!;

        return `${value.name}, ${line1}${line2 ? ', ' + line2 : ''}, 
                ${city}, ${state}, ${postal_code}, ${country}`;
    }
    else if (value && 'line1' in value) {
        const { line1, line2, city, state, postalCode, country } = (value as ShippingAddress)!;

        return `${value.name}, ${line1}${line2 ? ', ' + line2 : ''}, 
                ${city}, ${state}, ${postalCode}, ${country}`;
    }
    else
        return 'Unknown Address';
}


-- cardPipe.pipe.ts --
transform(value?: ConfirmationToken['payment_method_preview'] | PaymentSummary, ...args: unknown[]): unknown {
    if (value && 'card' in value && value.card) {
        const { brand, last4, exp_month, exp_year } = 
            (value as ConfirmationToken['payment_method_preview']).card!;

        return `${brand.toUpperCase()} **** **** **** ${last4} , Exp: ${exp_month}/${exp_year}`;
    }
    else if (value && 'last4' in value) {
        const { brand, last4, expMonth, expYear } = value as PaymentSummary;

        return `${brand.toUpperCase()} **** **** **** ${last4} , Exp: ${expMonth}/${expYear}`;
    }
    else
        return 'Unknown payment method';
}


-- Dictionary --

What is a pipe in Angular?
-> a feature that allows you to transform data before displaying it in the view
-> take in data as input and transform it to a 
desired output format without changing the original data
-> ex: {{order.shippingAddress | address }}
https://next.angular.dev/guide/templates/pipes


What is type guard in Angular?
-> a technique used to determine the type of an object at runtime
-> methods: typeof, instanceof, in(for properties)
https://blog.logrocket.com/how-to-use-type-guards-typescript/