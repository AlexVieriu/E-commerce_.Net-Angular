159. Introduction
-> creating a Stripe account
-> PCI DSS Compliance
-> Strong Customer Authentication
-> setting up Payment Intents
-> using Stripe Elements
-> confirming Card payments

Goal: 
-> able to accept payments securely globally that complies with EU regulations and PCI DSS regulations

PCI DSS: Payment Card Industry Data Security Standard
-> set of industry standards
-> designed to protect payment card data
-> 12 broad requirements and collectively more than 200 line item requirements

6 key requirements:
-> building and maintaining a secure network
-> protecting cardholder data
-> maintaining a vulnerability management program
-> implementing strong access control measures
-> regular monitor and test networks
-> maintaining an information security policy

PCI DSS non-compliance consequences(don't take credit cards directly):
-> monthly financial penalties from 5000$ to 100.000$
-> infringement consequences ($50 to 90$ per card holder whose information has been endangered)
-> compensation costs
-> legal action 
-> damaged reputation
-> revenue loss
-> federal audits

Strong Customer Authentication:
-> EU standards for authenticating online payments
-> Requires 2 of the 3 elements:
    -> something that Customer 
        -> knows (pass or pin)
        -> has (phone or hardware token)
        -> is (fingerprint)
-> Banks will decline payments that require SCA and don't need this criteria


-- Stripe without SCA(USA and Canadian payments only) : 16.159.jpg  --
1. User -> API              : Create order on API
2. Api -> User -> Stripe    : If successful, make payment to Stripe
3. Stripe -> User           : Stripe return one time use token if payment is successful
4. Client -> API            : Client sends token to the API
5. API -> Stripe            : API sends token to Stripe
6. Stripe -> Client         : Stripe confirms token
7. API -> Client            : On success/failure result sent to the Client


-- Stripe with SCA(Accept payments globally) --
1. User -> API      : Create payment intent with API(before payment)
2. API -> Stripe    : API sends payment intent to Stripe
3. Stripe -> API    : Stripe returns payment intent returns client secret
4. API -> Client    : API return client secret to client
5. USer -> Stripe   : Client sends payment ton Stripe using the client secret
6. Stripe -> User   : Stripe sends confirmation to the client
7. User -> API      : Client creates order with API
8. Stripe -> API    : Stripe sends conformation to API that payment was successful


160. Creating the delivery methods in the API 

-- Core -> Entities -> DeliveryMethod.cs --
-> Id, ShortName, DeliveryTime, Description, Price

-- Infrastructure -> Config -> ProductConfiguration.cs --
-> inherits from IEntityTypeConfiguration
-> implement Configure()
 -> add .Price property with decimal(18,2)

-- StoreContext.cs --
-> add DbSet<DeliveryMethod>

-- Infrastructure -> Data -> Seed Data -> delivery.json --

-- StoreContextSeed.cs --
-> add delivery methods

Create a new migration:
-> we need to be in the skinet folder
cd .. 
dotnet ef migrations add DeliveryMethodsAdded -s API -p Infrastructure
-> double check the migration file
cd API
dotnet watch


Dictionary: 

-- IEntityTypeConfiguration --
https://learn.microsoft.com/en-us/ef/core/modeling/ 

->  enables you to separate entity configuration logic from your DbContext, following 
a "configuration class per entity" pattern
-> each entity gets its own dedicated configuration class

-- EntityTypeBuilder --
https://learn.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.metadata.builders.entitytypebuilder?view=efcore-9.0

-> a fluent API that provides methods for configuring various aspects of your entity
    -> Primary keys and alternate keys
    -> Relationships between entities
    -> Property constraints (required, length, etc.)
    -> Indexes
    -> Default values
    -> Table mapping
    -> Shadow properties

-> this approach significantly improves code organization in larger projects with many entities, 
keeping your configurations clean, focused, and maintainable


required vs [Required]
https://stackoverflow.com/questions/75891221/required-vs-required-in-c-sharp-11

required:
-> enforces initialization at compile time

[Required]
-> enforces initialization at runtime


161. Setting up Stripe
https://dashboard.stripe.com/test/dashboard

-> create new account 
    -> name     : skinet-2024
    -> country  : United States 

For developers:
-> publish key  : we give to the client
-> secret key   : only in our server

-> add the keys on our configuration file

-- API -> appsettings.json --
-> we save it here, because appsettings.json will not be saved on GitHub

Add Stripe:
<PackageReference Include="Stripe.net" Version="47.4.0" />

-- Core -> Interfaces -> IPaymentService.cs --
CreateOrUpdatePaymentIntent(string cartId)

-- Infrastructure -> Services -> PaymentService.cs --
CreateOrUpdatePaymentIntent(string cartId)

-- Program.cs --
builder.Services.AddScoped<IPaymentService, PaymentService>();


162. Implementing the payment intent

-- ShoppingCart.cs --
-> add PaymentIntentId, ClientSecret, DeliveryMethodId

-- PaymentService.cs --

Services needed:
-> IConfiguration
-> ICartService
-> IGenericRepository<Product>
-> IGenericRepository<DeliveryMethod>

CreateOrUpdatePaymentIntent(string cartId):
-> get SecretKey from configuration (appsettings.json)
-> get cart from Redis
-> if cart.DeliveryMethodId.HasValue
    -> get delivery method
    -> calculate shipping price
-> for each item in the cart
    -> get the Product
    -> check if the price has changed
    -> create PaymentIntentService obj
    -> create PaymentIntent
        -> if no PaymentIntentId, create a PaymentIntentCreateOptions obj
            -> update amount, currency, payment method
            -> create the intentService
        -> else create a PaymentIntentUpdateOptions obj
            -> update amount 
            -> update the intentService
-> setCartService with the new cart created/updated
-> return cart


163. Creating a payment controller

Task<ActionResult<ShoppingCart>> CreateOrUpdatePaymentIntent(string cartId)
-> get the cart by from PaymentService 

Task<ActionResult<IReadOnlyList<DeliveryMethod>>> GetDeliveryMethods()


Postman:

-- Update Cart --
{{localhost}}/api/cart

{
  "id": "cart1",
  "items": [
    {
      "productId": 17,
      "productName": "Angular Purple Boots",
      "price": 1,
      "quantity": 2,
      "pictureUrl": "https://localhost:5150/images/products/boot-ang2.png",
      "brand": "Angular",
      "type": "Boots"
    }
  ]
}


-- Create Payment Intent as tom--
-> login as tom

{{localhost}}/api/payments/cart1

-> check Stripe:
https://dashboard.stripe.com/test/payments


-- Update Cart - Add payment intent details --

{{localhost}}/api/cart1

{
    "id": "cart",
    "items": [
        {
            "productId": 17,
            "productName": "Angular Purple Boots",
            "price": 1,
            "quantity": 2,
            "pictureUrl": "https://localhost:5150/images/products/boot-ang2.png",
            "brand": "Angular",
            "type": "Boots"
        }
    ],
    "deliveryMethodId": null,
    "clientSecret": "pi_3R3IsTGMOucV11Le1oj03Xlr_secret_z00B8mXlWho7KiMf0Fq4cCCUh",
    "paymentIntentId": "pi_3R3IsTGMOucV11Le1oj03Xlr"
}

-> check if the intent is updated:  
    {{localhost}}/api/payments/cart1 

-> check Stripe:
https://dashboard.stripe.com/test/payments


154. Checkout page layout

-- checkout.component.ts --
import : [MatStepperModule]

-- checkout.component.html --
-> add stepper: 
https://next.material.angular.io/components/stepper/overview

<mat-stepper>
<mat-step>
    -> for: Payment, Delivery, Payment, Review

-- cart.component.html --
remove :   <div class="mx-auto max-w-screen-xl">

-> remove the checkout button:

-- order-summary.component.ts --
location = inject(Location); //  from angular/common

-- order-summary.component.html --
@if(location.path() !== '/checkout') { . . . }
